import os
import sys
from Constants import *
from Utils import *


def generate_mpu_layout(eeprom_userstart, flash_base, interrupt_vector_table_ram):
    powers_array = generate_powers_array()

    # Go to parent folder.
    mpu_file = open("..\Source\HAL\ST31_MPU_temp.c", "w+")

    mpu_file.write('#include <Globals/PLATFORM.H>\n')
    mpu_file.write('\n')
    mpu_file.write('// This file needs to be automatically generated by the MPU folder RunMe tool each time the map file changes.')
    mpu_file.write('\n')
    mpu_file.write('// The design doc is S:\Chips\ST\ST31\ST31_MPU_Design.docx.')
    mpu_file.write('\n\n')
    mpu_file.write('#ifdef MPU_STATIC\n')
    mpu_file.write('void MPUEnableConfig(void)\n')
    mpu_file.write('{\n')
    mpu_file.write('  /** \\note MPU Static\n')
    mpu_file.write('   * MPU Static protects: our vector table in RAM and OS code in EEProm. \n')
    mpu_file.write('   * See @ref requirement_46cd8922-9f32-487a-9b31-ab388ee9996d\n')
    mpu_file.write('   */\n\n')

    mpu_file.write('  // Turn off the MPU\n')
    mpu_file.write('  r_MPU_CTRL = 0x00000000;\n\n')

    mpu_file.write('  // Region 0 Enabled, for everything.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x00000000)| MPU_RBAR_VALID | 0);\n')
    mpu_file.write('  // Permission: r+w+x; SRD: 0b0000 0000; Size affected: 0x100000000; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RW | 0x00 << 8 | 0x%x << 1 | MPU_ENABLE);\n' % MAX_POWER)

    mpu_file.write('\n')

    mpu_file.write('  // Region 1 Enabled, for ST ROM.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x00000000 & 0xFFFFFF00)| MPU_RBAR_VALID | 1);\n')
    mpu_file.write('  // Permission: r+x; SRD: 0b0000 0000; Size affected: 0x100000; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0x00 << 8 | 0x13 << 1 | MPU_ENABLE);\n')

    mpu_file.write('\n')

    mpu_file.write('  // Region 2 Enabled, for ST System Flash memory.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x00800000 & 0xFFFFFF00)| MPU_RBAR_VALID | 2);\n')
    mpu_file.write('  // Permission: r+x; SRD: 0b0000 0000; Size affected: 0x8000; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0x00 << 8 | 0x0E << 1 | MPU_ENABLE);\n')

    mpu_file.write('\n')

    mpu_file.write('  // Region 3 Enabled, for our Vector Table.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x%x & 0xFFFFFF00)| MPU_RBAR_VALID | 3);\n' % interrupt_vector_table_ram)
    mpu_file.write('  // Permission: r+x; SRD: 0b1111 0000; Size affected: 0x80; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0xF0 << 8 | 0x07 << 1 | MPU_ENABLE);\n')

    mpu_file.write('\n')
    mpu_file.write('  // Only 4 regions available to protect our code.')
    mpu_file.write('\n')

    # Our code has to be protected, first, calculate the space it takes
    code_remaining = eeprom_userstart - flash_base
    region_base_address = flash_base
    for i in range(4, MPU_NO_REGIONS):
        # No more flash to protect
        if code_remaining == 0:
            mpu_file.write('\n')
            mpu_file.write('  // Region %d Disabled\n' % i)
            mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = (0x00000000 | MPU_RBAR_VALID | %d);\n' % i)
            mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = MPU_DISABLE;\n')

        # There is some code to protect
        else:
            # Look for the biggest power of two that fits inside the code
            for ii in range(len(powers_array)):
                if powers_array[ii] > code_remaining:
                    # We've surpassed the code, decrease it by one
                    ii -= 1

                    print("Region chosen: %x" % powers_array[ii])

                    mpu_file.write('\n')
                    mpu_file.write('  // Region %d Enabled.\n' % i)
                    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x%x & 0xFFFFFF00) | MPU_RBAR_VALID | %d);\n' % (region_base_address, i))
                    mpu_file.write('  // Permission: r+x; SRD; Size affected; Enabled;\n')
                    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0x00 << 8 | 0x%x << 1 | MPU_ENABLE);\n' % (MIN_POWER + ii))

                    # Update the code size remaining
                    code_remaining = code_remaining - powers_array[ii]
                    print("Code remaining: %x" % code_remaining)
                    # The next region will start in this address
                    region_base_address += powers_array[ii]
                    print("Next region: %x" % region_base_address)

                    break

    mpu_file.write('\n')
    mpu_file.write('  // Turn on the MPU\n')
    mpu_file.write('  r_MPU_CTRL = (/*MPU_CTRL_HFNMI_EN |*/ MPU_CTRL_EN);')
    mpu_file.write('\n')
    mpu_file.write('}')
    mpu_file.write('\n')
    mpu_file.write('#endif // MPU_STATIC')
    mpu_file.write('\n')

    mpu_file.close()

    if delete_and_rename_file() and code_remaining >= 0:
        print('A new ST31_MPU.c file has been generated successfully\n')
        print('You need to re-compile in Keil\n')

    else:
        print('ST31_MPU.c file has NOT been generated successfully. (need more than 8 regions?)\n')

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Please, enter EEProm_UserStart, Flash_Base and InterruptVectorTable_RAM addresses as parameters.")
        exit()

    generate_mpu_layout(int(sys.argv[1][2:], 16), int(sys.argv[2][2:], 16), int(sys.argv[3][2:], 16))
