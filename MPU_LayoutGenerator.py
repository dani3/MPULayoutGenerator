import sys
from Utils import *


def generate_mpu_layout(eeprom_userstart, flash_base, interrupt_vector_table_ram):
    powers_array = generate_powers_array()

    # Go to parent folder.
    mpu_file = open("..\Source\HAL\ST31_MPU_temp.c", "w+")

    mpu_file.write('#include <Globals/PLATFORM.H>\n')
    mpu_file.write('\n')
    mpu_file.write('// This file needs to be automatically generated by the MPU folder RunMe tool each time the map file changes.')
    mpu_file.write('\n')
    mpu_file.write('// The design doc is S:\Chips\ST\ST31\ST31_MPU_Design.docx.')
    mpu_file.write('\n\n')
    mpu_file.write('#ifdef MPU_STATIC\n')
    mpu_file.write('void MPUEnableConfig(void)\n')
    mpu_file.write('{\n')
    mpu_file.write('  /** \\note MPU Static\n')
    mpu_file.write('   * MPU Static protects: our vector table in RAM and OS code in EEProm. \n')
    mpu_file.write('   * See @ref requirement_46cd8922-9f32-487a-9b31-ab388ee9996d\n')
    mpu_file.write('   */\n\n')

    mpu_file.write('  // Turn off the MPU\n')
    mpu_file.write('  r_MPU_CTRL = 0x00000000;\n\n')

    mpu_file.write('  // Region 0 Enabled, for everything.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x00000000)| MPU_RBAR_VALID | 0);\n')
    mpu_file.write('  // Permission: r+w+x; SRD: 0b0000 0000; Size affected: 0x100000000; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RW | 0x00 << 8 | 0x%x << 1 | MPU_ENABLE);\n' % MAX_POWER)

    mpu_file.write('\n')

    mpu_file.write('  // Region 1 Enabled, for ST ROM.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x00000000 & 0xFFFFFF00)| MPU_RBAR_VALID | 1);\n')
    mpu_file.write('  // Permission: r+x; SRD: 0b0000 0000; Size affected: 0x100000; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0x00 << 8 | 0x13 << 1 | MPU_ENABLE);\n')

    mpu_file.write('\n')

    mpu_file.write('  // Region 2 Enabled, for ST System Flash memory.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x00800000 & 0xFFFFFF00)| MPU_RBAR_VALID | 2);\n')
    mpu_file.write('  // Permission: r+x; SRD: 0b0000 0000; Size affected: 0x8000; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0x00 << 8 | 0x0E << 1 | MPU_ENABLE);\n')

    mpu_file.write('\n')

    mpu_file.write('  // Region 3 Enabled, for our Vector Table.\n')
    mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x%x & 0xFFFFFF00)| MPU_RBAR_VALID | 3);\n' % interrupt_vector_table_ram)
    mpu_file.write('  // Permission: r+x; SRD: 0b1111 0000; Size affected: 0x80; Enabled;\n')
    mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0xF0 << 8 | 0x07 << 1 | MPU_ENABLE);\n')

    mpu_file.write('\n')
    mpu_file.write('  // Only 4 regions available to protect our code.')
    mpu_file.write('\n')

    # Our code has to be protected, first, calculate the space it takes
    code_remaining = eeprom_userstart - flash_base
    region_base_address = flash_base
    for i in range(4, MPU_NO_REGIONS):
        # No more flash to protect
        if code_remaining < powers_array[0]:
            mpu_file.write('\n')
            mpu_file.write('  // Region %d Disabled\n' % i)
            mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = (0x00000000 | MPU_RBAR_VALID | %d);\n' % i)
            mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = MPU_DISABLE;\n')

        # There is some code to protect
        else:
            code_protected_wo, region_size_wo = calculate_region_without_subregions(code_remaining, powers_array)
            code_protected_w, region_size_w, subregions_w = calculate_region_with_subregions(code_remaining, powers_array)

            code_protected = code_protected_wo if (code_protected_wo >= code_protected_w) else code_protected_w
            region_size = region_size_wo if (code_protected_wo >= code_protected_w) else region_size_w
            subregions = "00" if (code_protected_wo >= code_protected_w) else subregions_w

            mpu_file.write('\n')
            mpu_file.write('  // Region %d Enabled.\n' % i)
            mpu_file.write('  r_MPU_REGION_BASE_ADDRESS = ((0x%x & 0xFFFFFF00) | MPU_RBAR_VALID | %d);\n' % (int(region_base_address), i))
            mpu_file.write('  // Permission: r+x; SRD; Size affected: 0x%x; Enabled;\n' % int(code_protected))
            mpu_file.write('  r_MPU_REGION_ATTRIBUTE_AND_SIZE = (MPU_RO | 0x%s << 8 | 0x%s << 1 | MPU_ENABLE);\n' % (subregions, region_size))

            # Update the code remaining
            code_remaining -= code_protected
            # The next region will start in this address
            region_base_address += code_protected            

    mpu_file.write('\n')
    mpu_file.write('  // Turn on the MPU\n')
    mpu_file.write('  r_MPU_CTRL = (/*MPU_CTRL_HFNMI_EN |*/ MPU_CTRL_EN);')
    mpu_file.write('\n')
    mpu_file.write('}')
    mpu_file.write('\n')
    mpu_file.write('#endif // MPU_STATIC')
    mpu_file.write('\n')

    mpu_file.close()

    if delete_and_rename_file() and code_remaining >= 0:
        print('A new ST31_MPU.c file has been generated successfully\n')
        print('You need to re-compile in Keil\n')

    else:
        print('ST31_MPU.c file has NOT been generated successfully. (need more than 8 regions?)\n')


if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Please, enter EEProm_UserStart, Flash_Base and InterruptVectorTable_RAM addresses as parameters.")
        exit()

    generate_mpu_layout(int(sys.argv[1][2:], 16), int(sys.argv[2][2:], 16), int(sys.argv[3][2:], 16))
